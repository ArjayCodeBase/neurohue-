<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matching Shapes (Educational) | NeuroHue</title>
  <style>
    /* --- Shared topbar / layout styles (from flip.html) --- */
    :root{
      --teal:#268ea6;
      --dark:#093c44;
      --accent:#0e7fa8;
      --muted:#f3f6f7;
      --card-shadow: 0 4px 10px rgba(8,52,54,0.06);
      --sidebar-width:280px;
      --topbar-height:64px;
      --bg:#f5f7fa;
    }
    *{box-sizing:border-box}
    body{ margin:0; font-family:Arial, Helvetica, sans-serif; background:var(--bg); color:#08343a; min-height:100vh; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
    /* Topbar */
    .topbar{
      height:var(--topbar-height);
      background:var(--teal);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 14px;
      color:#fff;
      box-shadow: 0 1px 0 rgba(0,0,0,0.06);
      position:sticky;
      top:0;
      z-index:120;
    }
    .brand { display:flex; align-items:center; gap:10px; font-weight:700; }
    .brand img{ height:34px; width:34px; border-radius:6px; object-fit:cover }
    .brand .title { font-size:18px; white-space:nowrap; }
    .topbar-right { display:flex; align-items:center; gap:12px; position:relative; }

    .plan-badge{ background:#fff3cf; color:#7a5a10; padding:6px 10px; border-radius:10px; font-size:13px; display:flex; align-items:center; gap:6px; white-space:nowrap; }
    .profile { background: #0b2b2b; color: #fff; padding:6px 10px; border-radius:22px; display:flex; align-items:center; gap:10px; cursor:pointer; position:relative; min-width:48px; }
    .profile .avatar { width:34px;height:34px;border-radius:50%;background:#fff;color:var(--dark);display:flex;align-items:center;justify-content:center;font-weight:700; }
    .profile .name { font-weight:700; font-size:14px; color: #fff; white-space:nowrap; }

    /* layout */
    .page { display:flex; gap:0; min-height: calc(100vh - var(--topbar-height)); }
    /* Sidebar */
    .sidebar {
      width:var(--sidebar-width);
      background: #f9fbfc;
      border-right:1px solid #ebeff0;
      padding:18px;
      transform: translateX(-320px);
      transition: transform .22s ease;
      position:relative;
      z-index:30;
      flex-shrink:0;
      overflow:auto;
    }
    .sidebar.open { transform: translateX(0); box-shadow: 2px 0 14px rgba(0,0,0,0.05); }
    .nav-section { margin-top:6px; }
    .nav-item{ display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-radius:8px; cursor:pointer; color:#08343a; margin-bottom:6px; }
    .nav-item:hover{ background: #eef6f7; }
    .hamburger{ width:34px;height:34px;border-radius:6px;display:flex;align-items:center;justify-content:center;cursor:pointer;background:transparent;border:none;color:#fff;font-size:20px; }

    .content { flex:1; padding:24px 28px; overflow:auto; min-width:0; } /* min-width:0 to let flex child shrink on mobile */

    /* profile dropdown */
    .profile-menu{ position:absolute; right:18px; top:var(--topbar-height); background:#fff; border:1px solid #e6eef0; border-radius:8px; min-width:180px; box-shadow:0 6px 20px rgba(8,52,54,0.08); display:none; z-index:240; }
    .profile-menu.open{ display:block; }
    .profile-menu button{ width:100%; border:none; background:transparent; padding:10px 12px; text-align:left; cursor:pointer; }
    .profile-menu button:hover{ background:#f2f8f9; }

    /* activity submenu */
    .sublist { padding-left:6px; margin-top:6px; display:none; }
    .sublist.open { display:block; }
    .sublist .subitem { display:block; padding:8px 10px; border-radius:6px; cursor:pointer; font-size:14px; color:#2b4d50; text-decoration:none; }
    .sublist .subitem:hover { background:#eef6f7; }
    .sublist .subitem:focus { outline:2px solid #bfeef7; }

    /* backdrop for mobile sidebar */
    #backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.28); display:none; z-index:29; transition:opacity .18s; opacity:0; }
    #backdrop.show { display:block; opacity:1; }

    /* --- Shape game specific styles (kept from original, slightly adapted for layout) --- */
    .game-wrap { display:flex; flex-direction:column; align-items:center; width:100%; max-width:920px; margin: 18px auto; }
    h2 { margin-top: 6px; text-align:center; color:var(--dark); }

    .targets, .draggables {
      display:flex;
      justify-content:center;
      gap: 24px;
      margin: 20px;
      flex-wrap: wrap;
    }
    .target {
      width: 100px;
      height: 100px;
      display:flex;
      align-items:center;
      justify-content:center;
      position: relative;
    }
    .target svg { width:88px; height:88px; pointer-events:none; }
    .target .marker {
      position:absolute; font-size:20px; font-weight:bold; top:6px; right:8px; pointer-events:none;
    }
    .piece {
      width: 80px;
      height: 80px;
      cursor: grab;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      touch-action: none;
      -webkit-user-drag: none;
      position: relative;
    }
    .piece svg { width:68px; height:68px; }
    #feedback { margin-top:14px; font-weight:bold; text-align:center; }
    .timer { margin-top:8px; color:#333; font-size:0.95rem; }

    /* visual clone used while dragging */
    .dragging-clone {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      transform: translate(-50%, -50%);
      will-change: transform;
      opacity: 0.95;
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
      border-radius: 8px;
      background: white;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* responsive tweaks */
    @media (max-width:1024px){
      .content { padding:20px; }
      .sidebar { width: 260px; }
    }
    @media (max-width:900px){
      .sidebar {
        position: fixed;
        top:var(--topbar-height);
        left:0;
        height: calc(100vh - var(--topbar-height));
        transform: translateX(-320px);
        width: 260px;
        overflow:auto;
      }
      .sidebar.open { transform: translateX(0); }
      .brand .title { display:none; } /* save space */
      .plan-badge { display:none; } /* optional hide on small */
    }
  </style>
</head>
<body>
  <!-- TOPBAR -->
  <div class="topbar" role="banner">
    <div style="display:flex;align-items:center;gap:10px">
      <button id="hamburger" class="hamburger" title="Menu" aria-label="Open menu">☰</button>
      <div class="brand" aria-hidden="false">
        <img src="logo.png" alt="logo" />
        <div class="title">NeuroHue</div>
      </div>
    </div>

    <div class="topbar-right" style="position:relative">
      <div class="plan-badge" id="planBadge" aria-hidden="true">Basic Plan</div>

      <div id="profileBtn" class="profile" title="Account" aria-haspopup="true" aria-expanded="false">
        <div class="avatar" id="avatar">U</div>
        <div class="name" id="topUsername">Guest</div>
      </div>

      <div id="profileMenu" class="profile-menu" aria-hidden="true">
        <button id="viewProfileBtn">View Profile</button>
        <button id="goToAssess">Initial Assessment</button>
        <button id="logoutBtn">Log Out</button>
      </div>
    </div>
  </div>

  <div id="backdrop" role="presentation" aria-hidden="true"></div>

  <div class="page">
    <aside id="sidebar" class="sidebar" aria-hidden="true" aria-label="Main menu">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <strong style="font-size:14px">Menu</strong>
        <small style="color:#6b8e90">User Actions</small>
      </div>

      <div class="nav-section">
        <div class="nav-item" id="navDashboard" role="button" tabindex="0">
          <div>Dashboard</div><div style="font-size:13px;color:#6b8e90">⤴</div>
        </div>

        <div class="nav-item" id="navRoutine" role="button" tabindex="0">
          <div>Routine</div><div style="font-size:13px;color:#6b8e90">⤴</div>
        </div>

        <div class="nav-item" id="activityToggle" role="button" aria-expanded="false" tabindex="0">
          <div>Activity</div>
          <div id="activityToggleIcon" style="font-size:13px;color:#6b8e90">▸</div>
        </div>

        <div id="activitySub" class="sublist" aria-hidden="true" role="menu">
          <a class="subitem" data-activity="gross" href="gross.html" role="menuitem" tabindex="-1">Gross Motor Skills</a>
          <a class="subitem" data-activity="fine" href="fine.html" role="menuitem" tabindex="-1">Fine Motor Skills</a>
          <a class="subitem" data-activity="speech" href="speech.html" role="menuitem" tabindex="-1">Speech &amp; Learning</a>
          <a class="subitem" data-activity="cognitive" href="cognitive.html" role="menuitem" tabindex="-1">Cognitive &amp; Learning</a>
          <a class="subitem" data-activity="behavior" href="behavior.html" role="menuitem" tabindex="-1">Behavior &amp; Social Skills</a>
        </div>
      </div>

      <hr style="margin:14px 0;border:none;border-top:1px solid #eef4f5" />
      <div style="font-size:13px;color:#5f7a7c">Quick Links</div>
      <div style="height:8px"></div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button style="padding:8px 12px;border-radius:8px;border:1px solid #e6eef0;background:#fff;color:#2b4d50;cursor:pointer">Progress</button>
        <button style="padding:8px 12px;border-radius:8px;border:1px solid #e6eef0;background:#fff;color:#2b4d50;cursor:pointer">Reports</button>
      </div>
    </aside>

    <main class="content" role="main" id="mainContent">
      <h2>Matching Shapes (Educational)</h2>

      <div class="game-wrap">
        <div id="targetsList" class="targets" aria-label="Shape targets"></div>
        <div id="piecesList" class="draggables" aria-label="Draggable shapes"></div>
        <div id="feedback" role="status" aria-live="polite"></div>
        <div id="timerEl" class="timer" aria-hidden="true"></div>
      </div>
    </main>
  </div>

  <script>
    /* ----------- Robust stored user loader & header/sidebar behavior (from flip.html) ----------- */
    function $(id){ return document.getElementById(id); }

    function loadStoredUser() {
      const raw = localStorage.getItem('user') ?? sessionStorage.getItem('user')
               ?? localStorage.getItem('currentUser') ?? sessionStorage.getItem('currentUser')
               ?? localStorage.getItem('current_user') ?? sessionStorage.getItem('current_user');
      if (!raw) {
        const uname = localStorage.getItem('username') ?? sessionStorage.getItem('username');
        const uid = localStorage.getItem('user_id') ?? sessionStorage.getItem('user_id') ?? localStorage.getItem('userId') ?? sessionStorage.getItem('userId');
        return { id: uid || null, username: uname || 'Guest' };
      }
      try {
        const parsed = JSON.parse(raw);
        const userObj = parsed.user ?? parsed;
        const id = userObj.id ?? userObj.user_id ?? parsed.user_id ?? parsed.id ?? null;
        const username = userObj.username ?? userObj.name ?? parsed.username ?? parsed.email ?? 'Guest';
        return { id, username };
      } catch (e) {
        return { id: null, username: raw };
      }
    }

    const storedUser = loadStoredUser();
    $('topUsername').textContent = storedUser.username || 'Guest';
    $('avatar').textContent = (storedUser.username && storedUser.username.length>0) ? storedUser.username.charAt(0).toUpperCase() : 'G';

    // sidebar toggle + backdrop
    const hamburger = $('hamburger');
    const sidebar = $('sidebar');
    const backdrop = $('backdrop');
    let sidebarOpen = false;
    function setSidebar(open){
      sidebarOpen = !!open;
      sidebar.classList.toggle('open', sidebarOpen);
      sidebar.setAttribute('aria-hidden', String(!sidebarOpen));
      if (sidebarOpen) { backdrop.classList.add('show'); backdrop.setAttribute('aria-hidden','false'); }
      else { backdrop.classList.remove('show'); backdrop.setAttribute('aria-hidden','true'); }
    }
    hamburger.addEventListener('click', ()=> setSidebar(!sidebarOpen));
    backdrop.addEventListener('click', ()=> setSidebar(false));
    if (window.innerWidth > 900) { setSidebar(true); } else { setSidebar(false); }

    // profile dropdown
    const profileBtn = $('profileBtn');
    const profileMenu = $('profileMenu');
    let profileOpen = false;
    profileBtn.addEventListener('click', (e) => {
      profileOpen = !profileOpen;
      profileMenu.classList.toggle('open', profileOpen);
      profileMenu.setAttribute('aria-hidden', String(!profileOpen));
      profileBtn.setAttribute('aria-expanded', String(profileOpen));
    });
    document.addEventListener('click', (e)=> {
      if (!profileBtn.contains(e.target) && !profileMenu.contains(e.target)) {
        profileOpen = false;
        profileMenu.classList.remove('open');
        profileMenu.setAttribute('aria-hidden','true');
        profileBtn.setAttribute('aria-expanded','false');
      }
    });

    function doLogout(){
      const keys = ['user','currentUser','current_user','username','user_id','userId','userid','authToken','token','planName'];
      keys.forEach(k=>{ try{ localStorage.removeItem(k); sessionStorage.removeItem(k); } catch(e){} });
      window.location.href = 'signin.html';
    }
    $('logoutBtn')?.addEventListener('click', doLogout);
    $('viewProfileBtn')?.addEventListener('click', ()=> window.location.href='profile.html');
    $('goToAssess')?.addEventListener('click', ()=> window.location.href='initial_progress_assessment.html');

    // activity toggle (sidebar)
    const activityToggle = $('activityToggle');
    const activitySub = $('activitySub');
    const activityToggleIcon = $('activityToggleIcon');
    let activityOpen = false;
    if (activityToggle) {
      activityToggle.addEventListener('click', () => {
        activityOpen = !activityOpen;
        activitySub.classList.toggle('open', activityOpen);
        activityToggle.setAttribute('aria-expanded', String(activityOpen));
        activityToggleIcon.textContent = activityOpen ? '▾' : '▸';
        activitySub.querySelectorAll('.subitem').forEach(a => a.tabIndex = activityOpen ? 0 : -1);
        if (activityOpen) {
          const first = activitySub.querySelector('.subitem');
          if (first) first.focus();
        } else {
          activityToggle.focus();
        }
      });
      activityToggle.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.code === 'Space') { e.preventDefault(); activityToggle.click(); }
      });
    }
    document.querySelectorAll('#activitySub .subitem').forEach(a => a.tabIndex = -1);

    // nav handlers
    document.getElementById('navDashboard')?.addEventListener('click', ()=> { window.location.href = 'dashboard.html'; });
    document.getElementById('navRoutine')?.addEventListener('click', ()=> { window.location.href = 'routine.html'; });

    // when window resizes, auto open sidebar on wide screens
    window.addEventListener('resize', () => {
      if (window.innerWidth > 900) setSidebar(true);
    });

    /* ----------- Original shape game script (mostly unchanged) ----------- */

    // base API URL
    const baseURL = "https://neurohue.onrender.com";

    function getStoredItem(key) {
      return localStorage.getItem(key) ?? sessionStorage.getItem(key);
    }

    const learnerId = (function() {
      const keys = ['user_id','userId','userid'];
      for (const k of keys) {
        const v = getStoredItem(k);
        if (v !== null && v !== undefined) {
          const n = Number(v);
          return Number.isNaN(n) ? v : n;
        }
      }
      // fall back to storedUser.id if available
      return storedUser && storedUser.id ? storedUser.id : null;
    })();

    const authToken = (function(){ return getStoredItem('authToken') ?? getStoredItem('token'); })();

    let currentStage = 1;
    let correctThisStage = 0;
    let placedThisStage = 0;
    let shapesThisStage = 0;
    let totalCorrectAll = 0;
    let totalShapesAll = 0;

    // SVG templates (same as before)
    function svgOutlineTemplate(shape) {
      switch (shape) {
        case "circle": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><circle cx="40" cy="40" r="30" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "square": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="10" width="60" height="60" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "triangle": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,12 72,66 8,66" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "hexagon": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,10 65,25 65,55 40,70 15,55 15,25" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "pentagon": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,8 68,30 56,62 24,62 12,30" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "star": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,8 49,32 74,32 54,48 62,72 40,58 18,72 26,48 6,32 31,32" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "heart": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M40 60 L32 52 C16 36 26 20 40 30 C54 20 64 36 48 52 Z" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "crescent": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M52 40a20 20 0 1 1-28-18 14 14 0 1 0 28 18z" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "octagon": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="28,8 52,8 72,28 72,52 52,72 28,72 8,52 8,28" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "diamond": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,8 64,40 40,72 16,40" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "trapezoid": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="16,64 64,64 54,20 26,20" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        case "parallelogram": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="20,16 60,16 48,64 8,64" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
        default: return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="10" width="60" height="60" fill="none" stroke="#555" stroke-width="3" stroke-dasharray="6"/></svg>`;
      }
    }

    function svgFilledTemplate(shape) {
      switch (shape) {
        case "circle": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><circle cx="40" cy="40" r="30" fill="#e53935" /></svg>`;
        case "square": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><rect x="15" y="15" width="50" height="50" fill="#9ad3f0"/></svg>`;
        case "triangle": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,12 72,66 8,66" fill="#ffeb3b"/></svg>`;
        case "hexagon": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,10 65,25 65,55 40,70 15,55 15,25" fill="#8fd3a7"/></svg>`;
        case "pentagon": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,8 68,30 56,62 24,62 12,30" fill="#f6c667"/></svg>`;
        case "star": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,8 49,32 74,32 54,48 62,72 40,58 18,72 26,48 6,32 31,32" fill="#ffd54f"/></svg>`;
        case "heart": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M40 60 L32 52 C16 36 26 20 40 30 C54 20 64 36 48 52 Z" fill="#ec407a"/></svg>`;
        case "crescent": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M52 40a20 20 0 1 1-28-18 14 14 0 1 0 28 18z" fill="#90caf9"/></svg>`;
        case "octagon": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="28,8 52,8 72,28 72,52 52,72 28,72 8,52 8,28" fill="#b39ddb"/></svg>`;
        case "diamond": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="40,8 64,40 40,72 16,40" fill="#80cbc4"/></svg>`;
        case "trapezoid": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="16,64 64,64 54,20 26,20" fill="#ffab91"/></svg>`;
        case "parallelogram": return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><polygon points="20,16 60,16 48,64 8,64" fill="#c5e1a5"/></svg>`;
        default: return `<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><rect x="15" y="15" width="50" height="50" fill="#9ad3f0"/></svg>`;
      }
    }

    function makeTargetElement(shape) {
      const wrap = document.createElement("div");
      wrap.className = "target";
      wrap.dataset.shape = shape;
      wrap.dataset.occupied = "false";
      wrap.innerHTML = svgOutlineTemplate(shape) + `<div class="marker" aria-hidden="true"></div>`;
      // Desktop drag/drop support
      wrap.addEventListener("dragover", (e) => e.preventDefault());
      wrap.addEventListener("drop", onDropToTarget);
      return wrap;
    }

    // centralized drop handler logic (used by pointer-drop and dataTransfer drop)
    function handleDropToTarget(targetEl, payload) {
      if (!targetEl || targetEl.dataset.occupied === "true") return;
      targetEl.dataset.occupied = "true";
      placedThisStage++;

      const expected = targetEl.dataset.shape;
      const marker = targetEl.querySelector(".marker");

      if (payload.shape === expected) {
        correctThisStage++;
        marker.textContent = "✓";
        marker.style.color = "green";
      } else {
        marker.textContent = "✗";
        marker.style.color = "red";
      }

      // remove dragged element by id if provided, otherwise remove one candidate piece by shape
      if (payload.id) {
        const draggedEl = document.getElementById(payload.id);
        if (draggedEl && draggedEl.parentElement) draggedEl.parentElement.removeChild(draggedEl);
      } else {
        const candidate = document.querySelector(`#piecesList .piece[data-shape="${payload.shape}"]`);
        if (candidate && candidate.parentElement) candidate.parentElement.removeChild(candidate);
      }

      if (placedThisStage >= shapesThisStage) {
        setTimeout(submitStageResults, 700);
      }
    }

    // original drop handler (for desktop drag & drop)
    function onDropToTarget(e) {
      e.preventDefault();
      let payload;
      try { payload = JSON.parse(e.dataTransfer.getData("text/plain")); }
      catch { payload = { shape: e.dataTransfer.getData("shape"), id: null }; }
      handleDropToTarget(e.currentTarget, payload);
    }

    // create the piece element and attach pointer + drag handlers
    function makePieceElement(shape, idx) {
      const el = document.createElement("div");
      el.className = "piece";
      // we *do not* rely on HTML5 draggable for pointer/touch
      el.draggable = true; // keep true so desktop native drag still works; pointer handlers take precedence
      el.dataset.shape = shape;
      el.dataset.index = String(idx);
      el.id = `piece-${shape}-${idx}`;
      el.innerHTML = svgFilledTemplate(shape);

      // desktop dragstart (to keep docs working with mouse)
      el.addEventListener("dragstart", (ev) => {
        try {
          ev.dataTransfer.setData("text/plain", JSON.stringify({ shape: ev.currentTarget.dataset.shape, id: ev.currentTarget.id }));
        } catch (e) {
          // ignore dataTransfer errors
        }
      });

      // pointer-based dragging (unified for mouse & touch where supported)
      el.style.touchAction = "none"; // avoid gestures while dragging

      let pointerState = null; // holds clone and metadata during pointer drag

      function startPointerDrag(ev) {
        // only respond for primary pointer
        if (ev.pointerType && ev.isPrimary === false) return;
        ev.preventDefault();

        // create a floating clone to follow the pointer
        const clone = el.cloneNode(true);
        clone.classList.add("dragging-clone");
        clone.style.width = `${el.offsetWidth}px`;
        clone.style.height = `${el.offsetHeight}px`;
        document.body.appendChild(clone);

        pointerState = {
          id: `ptr-${Date.now()}-${Math.random().toString(36).slice(2,7)}`,
          clone,
          startX: ev.clientX,
          startY: ev.clientY,
          offsetX: ev.clientX - el.getBoundingClientRect().left - el.offsetWidth/2,
          offsetY: ev.clientY - el.getBoundingClientRect().top - el.offsetHeight/2,
          shape: el.dataset.shape,
          origId: el.id
        };

        // initial position
        moveClone(ev.clientX, ev.clientY);

        // capture pointer so we get events outside element
        try { (ev.target).setPointerCapture && ev.target.setPointerCapture(ev.pointerId); } catch(e){}

        window.addEventListener("pointermove", pointerMoveHandler);
        window.addEventListener("pointerup", pointerEndHandler);
        window.addEventListener("pointercancel", pointerEndHandler);
      }

      function moveClone(clientX, clientY) {
        if (!pointerState) return;
        const c = pointerState.clone;
        // center clone on finger/mouse
        c.style.left = `${clientX}px`;
        c.style.top = `${clientY}px`;
        c.style.transform = `translate(-50%,-50%)`;
      }

      function pointerMoveHandler(ev) {
        if (!pointerState) return;
        ev.preventDefault();
        moveClone(ev.clientX, ev.clientY);
      }

      function pointerEndHandler(ev) {
        if (!pointerState) return;
        // find the element under the pointer
        const x = ev.clientX;
        const y = ev.clientY;
        const elUnder = document.elementFromPoint(x, y);
        let targetEl = null;
        if (elUnder) {
          targetEl = elUnder.closest('.target');
        }
        // prepare payload similar to drag data
        const payload = { shape: pointerState.shape, id: pointerState.origId };

        if (targetEl) {
          handleDropToTarget(targetEl, payload);
        } else {
          // no target, just remove clone (no placement)
        }

        // cleanup
        try {
          window.removeEventListener('pointermove', pointerMoveHandler);
          window.removeEventListener('pointerup', pointerEndHandler);
          window.removeEventListener('pointercancel', pointerEndHandler);
        } catch(e){}
        if (pointerState.clone && pointerState.clone.parentElement) pointerState.clone.parentElement.removeChild(pointerState.clone);
        pointerState = null;
      }

      // attach pointerdown
      el.addEventListener("pointerdown", startPointerDrag);

      return el;
    }

    async function loadStage(stage) {
      correctThisStage = 0;
      placedThisStage = 0;
      shapesThisStage = 0;
      $('feedback').textContent = "";
      $('timerEl').textContent = "";

      try {
        const headers = {};
        if (authToken) headers['Authorization'] = `Bearer ${authToken}`;
        const resp = await fetch(`${baseURL}/shape-game/level/${stage}`, { headers });
        if (!resp.ok) {
          finalizeAndGoHome();
          return;
        }
        const data = await resp.json();
        renderStage(data);
      } catch (err) {
        $('feedback').textContent = "Network error while loading stage.";
        console.error(err);
      }
    }

    function renderStage(data) {
      const targetsRoot = document.getElementById("targetsList");
      const piecesRoot = document.getElementById("piecesList");
      targetsRoot.innerHTML = "";
      piecesRoot.innerHTML = "";

      shapesThisStage = data.shapes.length;
      data.outlines.forEach(shapeType => targetsRoot.appendChild(makeTargetElement(shapeType)));
      data.shapes.forEach((shapeType, idx) => piecesRoot.appendChild(makePieceElement(shapeType, idx)));

      $('feedback').textContent = `Playing stage ${data.level} — match ${shapesThisStage} shapes.`;
    }

    async function submitStageResults() {
      totalCorrectAll += correctThisStage;
      totalShapesAll += shapesThisStage;

      const payload = { user_id: learnerId, level: currentStage, matched_shapes: correctThisStage, total_shapes: shapesThisStage };

      try {
        const headers = { "Content-Type": "application/json" };
        if (authToken) headers['Authorization'] = `Bearer ${authToken}`;

        const resp = await fetch(`${baseURL}/shape-game/submit`, {
          method: "POST",
          headers,
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          const text = await resp.text();
          $('feedback').textContent = `Server error: ${resp.status} — ${text}`;
          return;
        }

        const result = await resp.json();
        $('feedback').textContent = `Stage ${currentStage} result: ${result.message} Score: ${result.score}%`;

        const nextAvailable = (typeof result.next_stage !== "undefined" && result.next_stage !== null) ? result.next_stage : null;

        let wait = 5;
        const timerEl = $('timerEl');
        if (!nextAvailable) {
          timerEl.textContent = `Returning to Home in ${wait} s...`;
          const t = setInterval(() => {
            wait--;
            if (wait > 0) {
              timerEl.textContent = `Returning to Home in ${wait} s...`;
            } else {
              clearInterval(t);
              finalizeAndGoHome();
            }
          }, 1000);
          return;
        }

        // next stage exists
        timerEl.textContent = `Next stage will start in ${wait} s...`;
        const t2 = setInterval(() => {
          wait--;
          if (wait > 0) {
            timerEl.textContent = `Next stage will start in ${wait} s...`;
          } else {
            clearInterval(t2);
            timerEl.textContent = "";
            currentStage = nextAvailable;
            loadStage(currentStage);
          }
        }, 1000);

      } catch (err) {
        $('feedback').textContent = "Network error while submitting results.";
        console.error(err);
      }
    }

    function finalizeAndGoHome() {
      const fb = $('feedback');
      if (totalShapesAll === 0) {
        fb.textContent = "No stages were played. Returning to Home...";
      } else {
        const pct = Math.round((totalCorrectAll / totalShapesAll) * 100);
        fb.innerHTML = `All stages complete.<br/>Total matched: ${totalCorrectAll} / ${totalShapesAll} — <strong>Total score: ${pct}%</strong><br/>Returning to Home...`;
      }

      try {
        localStorage.setItem("eduShapesCompleted", "true");
        localStorage.removeItem("eduShapesInProgress");
      } catch (e) { console.warn("localStorage unavailable:", e); }

      setTimeout(() => { window.location.href = "cognitive.html"; }, 1500);
    }

    function ensureLearnerLoggedIn() {
      if (!learnerId) {
        try { localStorage.setItem('eduShapesInProgress', 'true'); } catch(e) {}
        const fb = $('feedback');
        if (fb) fb.textContent = 'You must be logged in to play. Redirecting to signin...';
        setTimeout(() => { window.location.href = 'signin.html'; }, 900);
        return false;
      }
      return true;
    }

    document.addEventListener('DOMContentLoaded', () => {
      // ensure username in topbar uses stored user if available
      const username = loadStoredUser().username || getStoredItem('username') || 'Guest';
      $('topUsername').textContent = username;
      $('avatar').textContent = (username && username.length>0) ? username.charAt(0).toUpperCase() : 'G';

      if (!ensureLearnerLoggedIn()) return;
      loadStage(currentStage);
    });

  </script>
</body>
</html>
